package demo

import (
	"bytes"
	"strings"
	"testing"
	"time"
)

func TestDefaultVHSConfig(t *testing.T) {
	cfg := DefaultVHSConfig()

	if cfg.Output != "demo.gif" {
		t.Errorf("Output = %v, want 'demo.gif'", cfg.Output)
	}

	if cfg.Width != 120 {
		t.Errorf("Width = %v, want 120", cfg.Width)
	}

	if cfg.Height != 40 {
		t.Errorf("Height = %v, want 40", cfg.Height)
	}

	if cfg.Theme == nil {
		t.Error("Theme should not be nil")
	}
}

func TestDefaultVHSTheme(t *testing.T) {
	theme := DefaultVHSTheme()

	if theme.Background != "#1a1a2e" {
		t.Errorf("Background = %v, want '#1a1a2e'", theme.Background)
	}

	if theme.Foreground != "#eaeaea" {
		t.Errorf("Foreground = %v, want '#eaeaea'", theme.Foreground)
	}

	if theme.Cursor != "#bb86fc" {
		t.Errorf("Cursor = %v, want '#bb86fc'", theme.Cursor)
	}
}

func TestGenerateVHSTape(t *testing.T) {
	frames := []Frame{
		{Content: "Frame 1", Delay: 500 * time.Millisecond, Annotation: "First frame"},
		{Content: "Frame 2", Delay: 100 * time.Millisecond},
	}

	cfg := DefaultVHSConfig()
	cfg.Output = "test.gif"
	cfg.Width = 80
	cfg.Height = 24

	var buf bytes.Buffer
	err := GenerateVHSTape(&buf, frames, cfg)

	if err != nil {
		t.Fatalf("GenerateVHSTape() error = %v", err)
	}

	output := buf.String()

	// Check header
	if !strings.Contains(output, "# Generated by Plural Demo") {
		t.Error("Missing header comment")
	}

	if !strings.Contains(output, "Output test.gif") {
		t.Error("Missing Output directive")
	}

	if !strings.Contains(output, "Set Width 80") {
		t.Error("Missing Width setting")
	}

	if !strings.Contains(output, "Set Height 24") {
		t.Error("Missing Height setting")
	}

	// Check theme
	if !strings.Contains(output, "Set Theme") {
		t.Error("Missing Theme setting")
	}

	// Check sleep commands
	if !strings.Contains(output, "Sleep 500ms") {
		t.Error("Missing first sleep command")
	}

	// Check annotation comment
	if !strings.Contains(output, "# First frame") {
		t.Error("Missing annotation comment")
	}

	// Check final sleep
	if !strings.Contains(output, "Sleep 2s") {
		t.Error("Missing final sleep")
	}
}

func TestGenerateVHSTapeNoTheme(t *testing.T) {
	frames := []Frame{
		{Content: "Test", Delay: 100 * time.Millisecond},
	}

	cfg := DefaultVHSConfig()
	cfg.Theme = nil

	var buf bytes.Buffer
	err := GenerateVHSTape(&buf, frames, cfg)

	if err != nil {
		t.Fatalf("GenerateVHSTape() error = %v", err)
	}

	output := buf.String()

	// Should not contain theme setting
	if strings.Contains(output, "Set Theme") {
		t.Error("Should not have Theme setting when theme is nil")
	}
}

func TestEscapeForVHS(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{`"quoted"`, `\"quoted\"`},
		{`back\slash`, `back\\slash`},
		{"new\nline", `new\nline`},
		{"tab\there", `tab\there`},
		{"\x1b[0m", `\x1b[0m`},
		{"normal text", "normal text"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := escapeForVHS(tt.input)
			if result != tt.expected {
				t.Errorf("escapeForVHS(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestGenerateASCIICast(t *testing.T) {
	frames := []Frame{
		{Content: "Frame 1", Delay: 500 * time.Millisecond},
		{Content: "Frame 2", Delay: 100 * time.Millisecond},
	}

	var buf bytes.Buffer
	err := GenerateASCIICast(&buf, frames, 80, 24)

	if err != nil {
		t.Fatalf("GenerateASCIICast() error = %v", err)
	}

	output := buf.String()
	lines := strings.Split(strings.TrimSpace(output), "\n")

	// Should have header + one line per frame
	if len(lines) != 3 {
		t.Errorf("Expected 3 lines, got %d", len(lines))
	}

	// Check header
	if !strings.Contains(lines[0], `"version": 2`) {
		t.Error("Missing version in header")
	}

	if !strings.Contains(lines[0], `"width": 80`) {
		t.Error("Missing width in header")
	}

	if !strings.Contains(lines[0], `"height": 24`) {
		t.Error("Missing height in header")
	}

	// Check frame format
	if !strings.HasPrefix(lines[1], "[0.500000") {
		t.Errorf("First frame should start at 0.5s, got: %s", lines[1])
	}

	if !strings.Contains(lines[1], `"o"`) {
		t.Error("Frame should have output type")
	}
}

func TestEscapeForJSON(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{`"quoted"`, `\"quoted\"`},
		{`back\slash`, `back\\slash`},
		{"new\nline", `new\nline`},
		{"tab\there", `tab\there`},
		{"normal text", "normal text"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := escapeForJSON(tt.input)
			if result != tt.expected {
				t.Errorf("escapeForJSON(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}
