package demo

import (
	"encoding/json"
	"fmt"
	"io"
	"strings"
	"time"
)

// VHSConfig configures VHS tape generation.
type VHSConfig struct {
	// Output file (e.g., "demo.gif", "demo.mp4", "demo.webm")
	Output string

	// Terminal dimensions
	Width  int
	Height int

	// Font settings
	FontFamily string
	FontSize   int

	// Timing
	FrameRate int // Frames per second for output

	// Theme colors (optional, uses defaults if empty)
	Theme *VHSTheme
}

// VHSTheme defines the color theme for VHS output.
type VHSTheme struct {
	Background string
	Foreground string
	Cursor     string
	// ANSI colors 0-15
	Black         string
	Red           string
	Green         string
	Yellow        string
	Blue          string
	Magenta       string
	Cyan          string
	White         string
	BrightBlack   string
	BrightRed     string
	BrightGreen   string
	BrightYellow  string
	BrightBlue    string
	BrightMagenta string
	BrightCyan    string
	BrightWhite   string
}

// DefaultVHSConfig returns sensible defaults for VHS generation.
func DefaultVHSConfig() VHSConfig {
	return VHSConfig{
		Output:     "demo.gif",
		Width:      120,
		Height:     40,
		FontFamily: "JetBrains Mono",
		FontSize:   14,
		FrameRate:  30,
		Theme:      DefaultVHSTheme(),
	}
}

// DefaultVHSTheme returns a theme matching Plural's dark purple theme.
func DefaultVHSTheme() *VHSTheme {
	return &VHSTheme{
		Background:    "#1a1a2e",
		Foreground:    "#eaeaea",
		Cursor:        "#bb86fc",
		Black:         "#1a1a2e",
		Red:           "#ff6b6b",
		Green:         "#69db7c",
		Yellow:        "#ffd93d",
		Blue:          "#748ffc",
		Magenta:       "#bb86fc",
		Cyan:          "#66d9ef",
		White:         "#eaeaea",
		BrightBlack:   "#4a4a6a",
		BrightRed:     "#ff8787",
		BrightGreen:   "#8ce99a",
		BrightYellow:  "#ffe066",
		BrightBlue:    "#91a7ff",
		BrightMagenta: "#d0a9f5",
		BrightCyan:    "#99e9f2",
		BrightWhite:   "#ffffff",
	}
}

// GenerateVHSTape generates a VHS tape file from frames.
// VHS (https://github.com/charmbracelet/vhs) can then render this to GIF/MP4.
func GenerateVHSTape(w io.Writer, frames []Frame, cfg VHSConfig) error {
	var b strings.Builder

	// Write header settings
	b.WriteString("# Generated by Plural Demo\n")
	b.WriteString(fmt.Sprintf("Output %s\n", cfg.Output))
	b.WriteString("\n")

	// Terminal settings
	b.WriteString(fmt.Sprintf("Set Width %d\n", cfg.Width))
	b.WriteString(fmt.Sprintf("Set Height %d\n", cfg.Height))
	b.WriteString(fmt.Sprintf("Set FontFamily \"%s\"\n", cfg.FontFamily))
	b.WriteString(fmt.Sprintf("Set FontSize %d\n", cfg.FontSize))
	b.WriteString(fmt.Sprintf("Set Framerate %d\n", cfg.FrameRate))
	b.WriteString("\n")

	// Theme settings
	if cfg.Theme != nil {
		t := cfg.Theme
		b.WriteString(fmt.Sprintf("Set Theme { \"background\": \"%s\", \"foreground\": \"%s\", \"cursor\": \"%s\", \"black\": \"%s\", \"red\": \"%s\", \"green\": \"%s\", \"yellow\": \"%s\", \"blue\": \"%s\", \"magenta\": \"%s\", \"cyan\": \"%s\", \"white\": \"%s\", \"brightBlack\": \"%s\", \"brightRed\": \"%s\", \"brightGreen\": \"%s\", \"brightYellow\": \"%s\", \"brightBlue\": \"%s\", \"brightMagenta\": \"%s\", \"brightCyan\": \"%s\", \"brightWhite\": \"%s\" }\n",
			t.Background, t.Foreground, t.Cursor,
			t.Black, t.Red, t.Green, t.Yellow, t.Blue, t.Magenta, t.Cyan, t.White,
			t.BrightBlack, t.BrightRed, t.BrightGreen, t.BrightYellow, t.BrightBlue, t.BrightMagenta, t.BrightCyan, t.BrightWhite,
		))
		b.WriteString("\n")
	}

	// Hide cursor for cleaner output
	b.WriteString("Hide\n")
	b.WriteString("\n")

	// Write frames
	// VHS uses a "Show" command followed by raw content output
	// We'll use a different approach: write raw ANSI content directly
	for i, frame := range frames {
		// Add delay if specified
		if frame.Delay > 0 {
			ms := frame.Delay.Milliseconds()
			if ms > 0 {
				b.WriteString(fmt.Sprintf("Sleep %dms\n", ms))
			}
		}

		// Add annotation as a comment
		if frame.Annotation != "" {
			b.WriteString(fmt.Sprintf("# %s\n", frame.Annotation))
		}

		// For VHS, we need to output the frame content
		// VHS works by recording terminal output, so we use Printf/Type
		// However, for pre-rendered frames, we need a different approach
		//
		// The trick is to clear the screen and write the frame content
		// using the Output command (which writes raw text)
		if i == 0 {
			// First frame: just show it
			b.WriteString("# Initial frame\n")
		}

		// Clear screen and position cursor at top-left
		// Using ANSI escape sequences
		b.WriteString("Output \"\\x1b[2J\\x1b[H\"\n")

		// Write the frame content
		// Need to escape the content for VHS
		escaped := escapeForVHS(frame.Content)
		b.WriteString(fmt.Sprintf("Output \"%s\"\n", escaped))
		b.WriteString("\n")
	}

	// Final pause before ending
	b.WriteString("Sleep 2s\n")

	_, err := w.Write([]byte(b.String()))
	return err
}

// escapeForVHS escapes content for VHS Output command.
func escapeForVHS(content string) string {
	var b strings.Builder
	for _, r := range content {
		switch r {
		case '"':
			b.WriteString("\\\"")
		case '\\':
			b.WriteString("\\\\")
		case '\n':
			b.WriteString("\\n")
		case '\r':
			b.WriteString("\\r")
		case '\t':
			b.WriteString("\\t")
		case '\x1b':
			b.WriteString("\\x1b")
		default:
			if r < 32 {
				b.WriteString(fmt.Sprintf("\\x%02x", r))
			} else {
				b.WriteRune(r)
			}
		}
	}
	return b.String()
}

// GenerateASCIICast generates an asciinema cast file from frames.
// This is the v2 format used by asciinema.
func GenerateASCIICast(w io.Writer, frames []Frame, width, height int) error {
	// Write header
	header := fmt.Sprintf(`{"version": 2, "width": %d, "height": %d, "timestamp": %d, "title": "Plural Demo"}`,
		width, height, time.Now().Unix())
	if _, err := fmt.Fprintln(w, header); err != nil {
		return err
	}

	// Track cumulative time
	var elapsed time.Duration

	for _, frame := range frames {
		// Add the delay
		elapsed += frame.Delay

		// Each event is: [time, event_type, data]
		// event_type "o" is output
		seconds := float64(elapsed) / float64(time.Second)

		// Clear scrollback, home cursor, and clear screen (matches real asciinema)
		// Convert \n to \r\n for proper terminal line handling
		frameContent := strings.ReplaceAll(frame.Content, "\n", "\r\n")
		content := "\x1b[3J\x1b[H\x1b[2J" + frameContent

		// Use Go's json.Marshal to properly escape the string
		// This handles UTF-8 correctly
		jsonBytes, err := json.Marshal(content)
		if err != nil {
			return fmt.Errorf("failed to marshal frame content: %w", err)
		}
		// json.Marshal includes quotes, so we use the raw bytes
		jsonContent := string(jsonBytes)

		line := fmt.Sprintf("[%.6f, \"o\", %s]", seconds, jsonContent)
		if _, err := fmt.Fprintln(w, line); err != nil {
			return err
		}
	}

	return nil
}

// escapeForJSON escapes a string for JSON.
// Note: For asciinema cast generation, we now use json.Marshal instead.
func escapeForJSON(s string) string {
	var b strings.Builder
	for _, r := range s {
		switch r {
		case '"':
			b.WriteString("\\\"")
		case '\\':
			b.WriteString("\\\\")
		case '\n':
			b.WriteString("\\n")
		case '\r':
			b.WriteString("\\r")
		case '\t':
			b.WriteString("\\t")
		default:
			if r < 32 {
				b.WriteString(fmt.Sprintf("\\u%04x", r))
			} else {
				b.WriteRune(r)
			}
		}
	}
	return b.String()
}
